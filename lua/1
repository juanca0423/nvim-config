local dap = require('dap')
--local dapui = require('dapui')
local bufopts = { noremap=true, silent=true }

vim.keymap.set('n', '<leader>b', require('telescope.builtin').buffers, { desc = "Listar buffers" })

--Pone el "punto rojo" donde se detendrá el código.
vim.keymap.set('n', '<leader>db', dap.toggle_breakpoint)

-- Iniciar o continuar (Sustituye a F5)
vim.keymap.set('n', '<leader>dc', dap.continue, { desc = "Debug: Continuar" })

-- Paso a paso / Saltar línea (Sustituye a F10)
vim.keymap.set('n', '<leader>dn', dap.step_over, { desc = "Debug: Siguiente línea" })
vim.keymap.set("n", "<leader>df", ":lua require('neogen').generate()<CR>", { desc = "Generar Documentación" })

-- Entrar en función (Sustituye a F11)
vim.keymap.set('n', '<leader>di', dap.step_into, { desc = "Debug: Entrar a función" })

-- Salir de función (Sustituye a F12)
vim.keymap.set('n', '<leader>do', dap.step_out, { desc = "Debug: Salir de función" })

-- Poner/Quitar punto de interrupción
vim.keymap.set('n', '<leader>db', dap.toggle_breakpoint, { desc = "Debug: Breakpoint" })

-- Reiniciar sesión de debug
vim.keymap.set('n', '<leader>dr', dap.restart, { desc = "Debug: Reiniciar" })

-- Detener debug y cerrar interfaz
vim.keymap.set('n', '<leader>du', function() require('dapui').toggle() end, { desc = "Toggle Debug UI" })

vim.keymap.set("n","<leader>e",":Ex<CR>")

local builtin = require('telescope.builtin')
vim.keymap.set('n', '<leader>gg', ':term lazygit<CR>', { desc = "Abrir Lazygit" })

-- Atajos específicos para Go Tests
vim.keymap.set('n', '<leader>gt', function() require('dap-go').debug_test() end, { desc = "Depurar Test actual" })

vim.keymap.set('n', '<leader>gl', function() require('dap-go').debug_last_test() end, { desc = "Depurar último Test" })
-- -- Atajo para ver el historial
vim.keymap.set("n", "<leader>h", ":Telescope yank_history<CR>", { desc = "Historial de copiado" })

  -- Peticiones HTTP
vim.keymap.set('n', '<leader>hr', function() require('kulala').run() end, { desc = "Ejecutar petición HTTP" })

vim.keymap.set('n', '<leader>hn', function() require('kulala').jump_next() end, { desc = "Siguiente petición" })

vim.keymap.set('n', '<leader>hp', function() require('kulala').jump_prev() end, { desc = "Petición anterior" })
-- Cerrar buffer actual con un atajo rápido
vim.keymap.set('n', '<leader>q', ':bdelete<CR>', { desc = "Cerrar archivo" })

-- Renombrar variable/función en todo el proyecto
vim.keymap.set('n', '<leader>rn', vim.lsp.buf.rename, { desc = "Renombrar símbolo" })

-- Abrir terminal abajo
vim.keymap.set('n', '<leader>st', ':sp | terminal<CR>i', { desc = "Abrir Terminal" })

vim.keymap.set('n', '<leader>w', ':w<CR>')
vim.keymap.set('n', '<leader>W', ':wq<CR>')
vim.keymap.set('n', '<leader>ff', builtin.find_files,{})
vim.keymap.set('n', '<leader>fg', builtin.live_grep,{})
vim.keymap.set('n', '<C-n>', ':NvimTreeToggle<CR>', { silent = true })

-- Saltar al siguiente error/advertencia (API moderna)
vim.keymap.set("n", "]d", function() vim.diagnostic.jump({ count = 1 }) end, { desc = "Siguiente Error" })
--
-- -- Saltar al error anterior (API moderna)
vim.keymap.set("n", "[d", function() vim.diagnostic.jump({ count = -1 }) end, { desc = "Error Anterior" })
--
-- -- Ver el mensaje de error flotante (Esta se mantiene igual, pero si te da aviso usa esta:)
vim.keymap.set("n", "<leader>e", vim.diagnostic.open_float, { desc = "Ver mensaje de error" })

-- Buscar en los archivos que tienes abiertos actualmente (Buffers)
vim.keymap.set('n', '<leader>fb', require('telescope.builtin')
.buffers, { desc = 'Buscar Buffers' })

-- Buscar ayuda de Neovim (¡Super útil para comandos!)
vim.keymap.set('n', '<leader>fh', require('telescope.builtin')
.help_tags, { desc = 'Buscar Ayuda' })

-- Buscar el historial de archivos recientes (¡Muy útil si cerraste algo!)
vim.keymap.set('n', '<leader>fr', require('telescope.builtin')
.oldfiles, { desc = 'Archivos Recientes' })
vim.keymap.set('n', 'gd', vim.lsp.buf.definition, bufopts)

-- -- Ver implementaciones (Útil en Go para interfaces)
vim.keymap.set('n', 'gi',
vim.lsp.buf.implementation, bufopts)

-- -- Ver dónde se usa una función/variable
vim.keymap.set('n', 'gr', vim.lsp.buf.references, bufopts)
-- -- Ver firma de la función (qué argumentos recibe)
vim.keymap.set('n', 'K', vim.lsp.buf.hover, bufopts)

-- Ver documentación (Hover)
vim.keymap.set('n', 'K', vim.lsp.buf.hover, { desc = "Ver documentación" })

-- Ver ayuda de firma (mientras escribes los argumentos)
vim.keymap.set('i', '<C-k>', vim.lsp.buf.signature_help, { desc = "Ayuda de firma" })

-- Salir de la terminal más fácil con Esc Esc
vim.keymap.set('t', '<Esc><Esc>', [[<C-\><C-n>]], { desc = "Salir modo terminal" })

require("toggleterm").setup({
  size = 15, -- Tamaño de la terminal
  open_mapping = [[<C-\>]], -- Con Ctrl + \ la abres y cierras
  shade_terminals = true,
  direction = 'horizontal', -- Aparece abajo. También puedes usar 'float'
  close_on_exit = true,
})

-- Función para que Esc Esc funcione dentro de ToggleTerm
function _G.set_terminal_keymaps()
  local opts = {buffer = 0}
  vim.keymap.set('t', '<esc>', [[<C-\><C-n>]], opts)
  vim.keymap.set('t', 'jk', [[<C-\><C-n>]], opts)
end

-- Solo oculta el texto flotante (virtual text)
vim.keymap.set('n', '<leader>v', function()
  local is_enabled = vim.diagnostic.config().virtual_text
  vim.diagnostic.config({ virtual_text = not is_enabled })
end)

vim.keymap.set('n', '<Tab>', ':BufferLineCycleNext<CR>', { desc = "Siguiente pestaña" })

vim.keymap.set('n', '<S-Tab>', ':BufferLineCyclePrev<CR>', { desc = "Pestaña anterior" })

-- Abrir/Cerrar el bloque donde está el cursor (Toggle)
-- -- 'za' es el comando estándar, pero puedes crear uno con leader si prefieres:
vim.keymap.set('n', '<leader>zz', 'za', { desc = "Plegar/Desplegar bloque" })
--
-- -- Abrir todos los pliegues (Desplegar todo el archivo)
vim.keymap.set('n', 'zr', require('ufo').openAllFolds, { desc = "Abrir todos los pliegues" })
--
-- -- Cerrar todos los pliegues (Colapsar todo el archivo)  
vim.keymap.set('n', 'zm', require('ufo').closeAllFolds, { desc = "Cerrar todos los pliegues" })
--
-- -- Peek Fold (Ver qué hay dentro de un pliegue sin abrirlo)
-- -- Esto es genial: te muestra una ventanita flotante con el contenido
vim.keymap.set('n', 'zk', function()
  local winid = require('ufo').peekFoldedLinesUnderCursor()
  if not winid then
    vim.lsp.buf.hover() -- Si no hay pliegue, intenta mostrar información de LSP
  end
end, { desc = "Vista previa del pliegue" })


-- Buscar dentro de la carpeta de configuración de Neovim
vim.keymap.set('n', '<leader>fn', function()
    require('telescope.builtin').find_files({ cwd = vim.fn.stdpath("config") })
end, { desc = 'Buscar en Config de Neovim' })

 Función para obtener el estado de Harpoon
local function harpoon_status()
    local harpoon = require("harpoon")
    local marks = harpoon:list().items
    local current_file_path = vim.fn.expand("%:p:.")
    
    for i, item in ipairs(marks) do
        if item.value == current_file_path then
            return "󰛢 " .. i -- Muestra un icono de arpón y el número
        end
    end
    return ""
end

return {
  'nvim-lualine/lualine.nvim',
  dependencies = { 'nvim-tree/nvim-web-devicons' },
  opts = {
    options = {
      theme = 'catppuccin', -- O el tema que uses
      section_separators = { left = '', right = '' },
      component_separators = { left = '', right = '' },
    },
    sections = {
      lualine_b = { 
        'branch', 
        'diff', 
        'diagnostics' 
      },
      -- Añadimos Harpoon en la sección C (el centro)
      lualine_c = { 
        { 'filename', path = 1 }, -- path = 1 muestra la ruta relativa
        { harpoon_status, color = { fg = "#ff007c", gui = "bold" } } 
      },
      lualine_x = { 'encoding', 'fileformat', 'filetype' },
    },
  },
}


      -- ... (dentro de tu bucle for _, server in ipairs(servers) do)

      if server == "gopls" then
        opts.settings = {
          gopls = {
            completeUnimported = true, -- Esto es lo que te falta para ver 'fmt'
            usePlaceholders = true,    -- Añade paréntesis automáticamente
            analyses = {
              unusedparams = true,
            },
            staticcheck = true,
            gofumpt = true, -- Un formateo más estricto y limpio
          },
        }
      end

      -- Si server es lua_ls... (lo que ya tienes)
      if server == "lua_ls" then
         -- ... tu config de lua
      end

      vim.lsp.config(server, opts)
      vim.lsp.enable(server)


-- En tu callback del autocmd, para Go es mejor esto:
callback = function()
  if vim.bo.filetype == "go" then
    require('go.format').goimports() -- Mucho más rápido que el code_action genérico
  else
    vim.lsp.buf.format({ timeout_ms = 2000 })
  end
end
